import subprocess
import re
import os
import time
from AI import ask_gemini
from reader import TextNarrator

LOG_FILE = os.path.expanduser("~/motherboard.log")  # Same logbook as MotherBoard

class DependencyCollector:
    def __init__(self):
        self.narrator = TextNarrator()
        self.log_event("DependencyCollector initialized. Ready to collect dependencies.")

        self.prompt_template = """You are a Windows 11 CMD Script Generator Bot.

Your job is to determine whether the user's request requires collecting system-level information ("dependencies") from their device.

âœ… If dependencies ARE required (e.g., battery level, Wi-Fi status, file/folder search, disk usage, etc.):

    First, output a short human-readable text describing the process that will run in the background. Format this text as:
    # your short message here #

    Then, output only a valid Windows CMD batch script that collects the needed information and saves it to a file named dep.txt.

    âš ï¸ Do NOT use deprecated tools like WMIC.
    âœ… You may use PowerShell commands if called *through CMD* (e.g., `powershell -Command "..."`)
    âœ… Only use commands/tools that are available by default in a typical Windows 11 installation.
    âŒ Do NOT use Bash, Linux commands, or any third-party/external utilities.

âŒ If dependencies are NOT required (e.g., opening/closing apps, changing brightness, adjusting volume, launching websites):

    Return exactly this: --no

â˜‘ï¸ Do NOT include any markdown formatting, code blocks, or explanations.
â˜‘ï¸ Only output:

    # short message # followed by raw CMD script

    OR --no

ðŸ§  After running the script, the user will provide the contents of dep.txt along with their original request. You will use this to generate the final response.

The system is Windows 11, and all commands will be run inside Command Prompt (CMD) â€” not PowerShell or Bash."""

    def log_event(self, message):
        """Write a timestamped log entry to the shared log file."""
        timestamp = time.strftime("%Y-%m-%d %H:%M:%S")
        with open(LOG_FILE, "a", encoding="utf-8") as f:
            f.write(f"[{timestamp}] {message}\n")
        print(message)  # Also print to console for live debug

    def clean_files(self):
        for filename in ["run.bat", "dep.txt"]:
            with open(filename, "w", encoding="utf-8") as f:
                f.write("")
        self.log_event("Temporary files run.bat and dep.txt cleaned.")

    def get_dependency(self, user_text: str) -> str:
        if not user_text.strip():
            self.log_event("No command detected from user input.")
            return "No command detected."

        self.clean_files()
        full_prompt = f"{self.prompt_template}\n\nUser request:\n{user_text.strip()}"
        self.log_event(f"Sending prompt to Gemini: {user_text.strip()}")
        ai_response = ask_gemini(full_prompt).strip()
        self.log_event(f"Gemini response: {ai_response[:100]}...")  # Log first 100 chars

        if ai_response.lower() == "--no":
            self.log_event("No dependencies required.")
            return None

        narration_match = re.search(r"#(.*?)#", ai_response, re.DOTALL)
        narration = narration_match.group(1).strip() if narration_match else "Running dependency collection..."
        self.log_event(f"Narration extracted: {narration}")
        self.narrator.extract_and_speak(narration)

        script = ai_response.split("#")[-1].strip()
        with open("run.bat", "w", encoding="utf-8") as f:
            f.write(script)
        self.log_event("run.bat script written.")

        try:
            subprocess.run(["cmd.exe", "/c", "run.bat"], check=True)
            self.log_event("run.bat executed successfully.")
        except subprocess.CalledProcessError as e:
            self.log_event(f"Script execution failed: {e}")
            return f"Script execution failed: {e}"

        if os.path.exists("dep.txt"):
            with open("dep.txt", "r", encoding="utf-8", errors="ignore") as f:
                result = f.read().strip()
            self.log_event(f"Dependency output collected: {len(result)} characters.")
            self.clean_files()
            return result or "Dependency script ran but produced no output."

        self.log_event("No dep.txt generated by the script.")
        return "No dep.txt generated."

if __name__ == "__main__":
    collector = DependencyCollector()
    user_input = "read the text from the current window"
    output = collector.get_dependency(user_input)
    print("Output:", output)
